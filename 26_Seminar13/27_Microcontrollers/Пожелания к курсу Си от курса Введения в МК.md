# 1. Процесс сборки
По сборке (препроцессирование → компиляция → линковка) на удивление вопросов особо нет. Есть один уже на курсе Владмира (STM32),когда нужно к своему проекту подлкючить библиотеку, собранную без поддержки FPU (есть такой прикол у ST), но там так и надо.

# 2. Битовые операции

Тут все всё знают, но часто не очень понимают. На самом деле полезны будут задачи такого рода:

1. Написать пару функций, одна из которых будет устанавливать все биты, а другая — снимать по маске. Возможное решение: bits.c
Простейшая вещь, но довольно полезная (особенно в контексте того, что именно так работает большинство флешек).

2. Прочесть из потока ввода число типа float и затем вывести его на экран в формате a*2\^b, где a и b — десятичные числа, причём а в диапазоне от [0,1; 1). Возможное решение: float.c. думал спервадать задачу на полноценный вывод, но сложновато получится на мой взгляд. Пример решения: float.c 

3. Реализовать работу с битовым массивом. Ну, то есть функции setbit(uint8_t *array, index, value), int getbit (uint8_t * array, index), тиакие, чтобы устанавливали (забирали) index-й бит по счёту в массиве array. Тоже несложно, но мозг прочистит. Пример, bit_array.c (там немного другие прототипы, т.к. я не понял, как удобнее формулировать задание).

# 3. Адресная арифметика и указатели 

Тоже — все всё знают, а сказать не могут.

1. Пример: address.c. Написать функцию set_value, устанавливающую значение по заданному в виде целого числа адресу.


2. Пример: union.c. Написать typedef для 32-битного типа с названием my_type таким образом, чтобы можно было обращаться к байтам(поле с названием byte), полусловам(u16), словам (u32) и числам с плавающей запятой (f). Ибо это туда же.

3. Пример: ihex.c. Написать функцию print_array_similarly_to_intel_hex(void* addr, int len) (название условное, естественно), выводящую на экран массив в следующем текстовом формате (все числа выводятся шестнадцатеричными числами в верхнем регистре, по два символа на байт):

    1. Первая строка: двоеточие, затем все байты адреса, кроме двух младших;
    
    2. Каждая следующая строка содержит данные, разложенные по полям:
        
        1. Двоеточие (`':'`)
        
        2. Первое поле —  два байта (младшие два байта тех данных, которые выводятсяв данной строке — для первой строки данных это будут просто два младших байта переменной `addr`, для каждой следующей строки прибавляем к предыдущему адресу число байтов данных, записанных в предыдущей строке).
        
        3. Второе поле — число 00
        
        4. Третье поле — данные (не более 16 байтов, подряд)
        
        5. Четвёртое поле — один байт, считающийся как сумма всех предыдущих байтов в строке (с переполнением, разумеется).

# 4. Работа с текстом

1. Это посложнее, но для тренирвоки перед курсовиком… Ну, в идеале: сделать парсер файла (функцию с прототипом `int parse_xpm(char ** xpm, uint16_t *result)` ) формата XPM (с одной стороны, PBM проще, с другой — есть две его версии, что не очень удобно в учебных целях). Задача: есть ~~текстовый файл~~ массив строк заданного формата с xpm внутри (один символ на точку, два цвета), необходимо найти строку, определяющую чёрный цвет и проанализировать файл, записывая в массив форму кривой — то есть её координату y для каждой координаты x (считаем, что эта зависимость однозначна). Возвращаемое значение функции — ширина изображения. Например, xpm.c
